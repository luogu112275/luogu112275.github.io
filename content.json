{"pages":[{"title":"关于我","text":"一名OIER，欢迎大家来我的github项目上立issues。 我尽力去解决问题","link":"/about/index.html"}],"posts":[{"title":"BSGS","text":"一种求解$a^x\\equiv b\\pmod{m}$的方法 引子我们之前学习了如何解这种方程$x\\equiv b_1\\pmod{m_1}$。 我们可以用扩展中国剩余定理或者欧拉定理 正文问题求最小的$x$使得$a^x\\equiv b\\pmod{m},\\gcd(a,m)=1$ 在没有学过BSGS北上广深之前，我们用暴力循环可以解决这一个问题。 时间复杂度$O(\\varphi(m))$（提示：模的循环节） 但是如果$m$为质数的话$\\varphi(m)=m-1$时间复杂度很高。 BSGS就是用来解决高次同余方程的。 解法BSGS本质上就是一个优化后的暴力算法 我们构造一个$x=At-B$，那么$a^x=a^{At-B}\\equiv b\\pmod{m}$ 于是我们移项一下得到$a^{At}\\equiv ba^B\\pmod{m}$ 求出$A=\\lceil\\frac{x}{t}\\rceil,B=x\\%t$，推出$B\\in[0,t),A\\in[0,\\lceil\\frac{x}{t}\\rceil)$ 此时我们先预处理出$ba^B$的所有值，在一一比对。 此时我们构造$t=\\sqrt{\\varphi(m)}$使得时间复杂度为$O(\\sqrt{m})$ 在代码中我们直接取$t=\\sqrt(m)+1$就可以了，身去了求$\\varphi$的时间。 注意$\\gcd(a,m)=1$ 代码P3846 [TJOI2007] 可爱的质数/【模板】BSGS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll qpow(ll a, ll n, ll p) //快速幂{ ll ans = 1; a %= p; while(n) { if(n &amp; 1) ans = ans * a % p; a = a * a % p; n &gt;&gt;= 1; } return ans;}ll BSGS(ll a, ll b, ll m){ //unordered_map&lt;ll, ll&gt; hs; //unordered_map是一个STL自带的哈希表 map&lt;ll, ll&gt; hs; //map 多一个 log ll cur = b * a % m, t = sqrt(m) + 1; //向上取整 for (int B = 1; B &lt;= t; B++) { hs[cur] = B; // 哈希表存B的值 cur = cur * a % m; } ll val = qpow(a, t, m); cur = val; // a^t for(int A = 1; A &lt;= t; A++) { if(hs[cur]) return A * t - hs[cur]; cur = (cur * val) % m; //再乘一个a^t次方 } return -1; // 无解}int main(){ int p, b, n; cin &gt;&gt; p &gt;&gt; b &gt;&gt; n; int res = BSGS(b, n, p); if(res == -1) cout &lt;&lt; &quot;no solution&quot;; else cout &lt;&lt; res; return 0;} P2485 [SDOI2011]计算器 唯一要注意的是我们要特判$y,p$不互质的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longint T , K , y , z , p , ans;inline int quickly_pow(int x , int y , int z){ int res = 1; while(y != 0){ if(y % 2 == 1){ res = res * x % z; } x = x * x % z; y &gt;&gt;= 1; } return res;}inline int BSGS(int a , int b , int m){ unordered_map &lt;int , int&gt; Hash; int cur = a * b % m , t = sqrt(m) + 1; for(int B = 1 ; B &lt;= t ; B++ ){ Hash[cur] = B; cur = cur * a % m; } int val = quickly_pow(a , t , m); cur = val; for(int A = 1 ; A &lt;= t ; A++ ){ if(Hash[cur] != 0){ return A * t - Hash[cur]; } cur = (cur * val) % m; } return -1;}inline int read(){ int s = 0 , w = 1; char ch = getchar(); while((ch &lt; '0') || (ch &gt; '9')){ if(ch == '-'){ w = -1; } ch = getchar(); } while((ch &gt;= '0') &amp;&amp; (ch &lt;= '9')){ s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + ch - '0'; ch = getchar(); } return s * w;}inline void write(int x){ if(x &lt; 0){ putchar('-'); x = -x; } if(x &gt; 9){ write(x / 10); } putchar(x % 10 + '0'); return ;}signed main(){ T = read(); K = read(); if(K == 1){ for(int i = 1 ; i &lt;= T ; i++ ){ y = read(); z = read(); p = read(); printf(&quot;%lld\\n&quot; , quickly_pow(y , z , p)); } } if(K == 2){ for(int i = 1 ; i &lt;= T ; i++ ){ y = read(); z = read(); p = read(); y %= p; if(y == 0){ cout &lt;&lt; &quot;Orz, I cannot find x!&quot; &lt;&lt; endl; } else{ printf(&quot;%lld\\n&quot; , quickly_pow(y , p - 2 , p) * z % p); } } } if(K == 3){ for(int i = 1 ; i &lt;= T ; i++ ){ y = read(); z = read(); p = read(); y %= p; if(y == 0){ cout &lt;&lt; &quot;Orz, I cannot find x!&quot; &lt;&lt; endl; } else{ ans = BSGS(y , z , p); if(ans == -1){ cout &lt;&lt; &quot;Orz, I cannot find x!&quot; &lt;&lt; endl; } else{ cout &lt;&lt; ans &lt;&lt; endl; } } } } return 0;} 扩展如果是$a^x\\equiv b\\pmod{m}$，$a,m$不互质了呢？ 我们将$a$写成$a=a_1\\times g$，$m=m_1\\times g$ 同时将原方程转化成不定方程$a\\times a^{x-1}+my=b$ 因为$a,m,b$中都有$g$就可以转化为$(a/g)\\times a^{x-1}+(m/g)y=b/g$ 我们又把它变成一个同余方程$(a/g)a^{x-1}\\equiv b/g\\pmod{m/g}$ 这样反复迭代就可以了 P4195 【模板】扩展BSGS 核心代码 1234567891011121314151617181920212223242526272829303132333435ll BSGS(ll a, ll b, ll m, ll k = 1) // 带系数k的BSGS，默认为1 { //unordered_map&lt;ll, ll&gt; hs; //unordered_map是一个STL自带的哈希表 map&lt;ll, ll&gt; hs; //map 多一个 log ll cur = b * a % m, t = sqrt(m) + 1; //向上取整 for (int B = 1; B &lt;= t; B++) { hs[cur] = B; // 哈希表存B的值 cur = cur * a % m; } ll val = qpow(a, t, m); cur = val * k % m; // a^t for(int A = 1; A &lt;= t; A++) { if(hs[cur]) return A * t - hs[cur]; cur = (cur * val) % m; //再乘一个a^t次方 } return -1000; //无解，返回一个小一点的负数，确保多次加1后仍然是负数 }ll exBSGS(ll a, ll b, ll m, ll k = 1){ if(b == 1) // 特判1，x&gt;0, 所以b==1，则x=0 return 0; if(a == 0 &amp;&amp; b == 0) // 特判2，底数为0，最小的x=1， 因为0^0 = 1 return 1; ll d = gcd(a, m); if(b % d != 0) // 无解, 斐蜀定理 return -1000; else if(d == 1) return BSGS(a, b, m, k % m); // 递归结束 return exBSGS(a, b / d, m / d, k * a / d % m) + 1; // 递归}","link":"/2021/07/14/BSGS/"},{"title":"Mobius反演","text":"一些莫反的东西 警告，本文含有大量数学公式容斥原理有$n$个集合$S_n$ |\\bigcup_{i=1}^n S_i|=\\sum\\limits_{i=1}^n|S_i|-\\sum\\limits_{1\\leq i1\\\\ 1, \\forall i \\in [1,k], c_i=1,(k为偶数)\\\\ -1, \\forall i \\in [1,k], c_i=1,(k为奇数) \\end{cases}用代码求1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;void mobius(int n){ for(int i = 1; i &lt;= n; i++) { miu[i] = 1; vis[i]= false; } for(int i = 2; i &lt;= n; i++) { if(vis[i] == true) continue; miu[i] = -1; //质数自己 ,-1 for(int j = 2*i; j &lt;= n; j+=i) { vis[j] = true; if(j % (i*i) == 0) miu[j] = 0; else miu[j] *= -1; //取相反数, j的质因数可能有多个，奇数个就是-1 } } return ; }int main(){ return 0;} 数论函数（算术函数）定义域在正整数上的函数 我们总的来说分为两类：加性函数和积性函数 加性函数如果$\\gcd (a,b)=1$，那么$f(a+b)=f(a)+f(b)$ 完全加性函数:$a,b$不一定互质 积性函数$a,b$互质且$f(1)=1$，$(fg)(n)=f(n)g(n)$ 完全积性函数:$a,b$不一定互质 狄利克雷卷积形式形式1 $(f*g)(n)=\\sum\\limits_{xy=n} f(x)\\times g(y)$ 形式2 $(f*g)(n)=\\sum\\limits_{d|n} f(d)\\times g(\\frac{n}{d})$ 性质性质一交换律，结合律，分配律 性质二普及一个概念：单位函数 \\epsilon(n)= \\begin{cases} 1,n=1\\\\ 0,n>1 \\end{cases}我们就有 (f*\\epsilon)(n)=\\sum\\limits_{d|n} \\epsilon(d)\\times f(\\frac{n}{d})=f(n)考虑$d=1$时 性质三若$f,g$都是积性函数 那么$(f*g)(n)$也是积性函数 证明： (f*g)(1)=f(1)g(1)=1设$a,b$互质 (f*g)(a)=\\sum\\limits_{d|a} f(d)\\times g(\\frac{a}{d})...(1)(f*g)(b)=\\sum\\limits_{d|b} f(d)\\times g(\\frac{b}{d})...(2)(f*g)(ab)=\\sum\\limits_{d|ab} f(d)\\times g(\\frac{ab}{d})...(3)$(1)*(2)$得 \\sum\\limits_{d1|a} f(d1)\\times g(\\frac{a}{d1}) \\times \\sum\\limits_{d2|b} f(d2)\\times g(\\frac{b}{d2})整理得（乘法原理） \\sum\\limits_{d1|a,d2|b} f(d1) * g(\\frac{a}{d1})\\times f(d2) * g(\\frac{b}{d2})所以有 \\sum\\limits_{d1|a,d2|b} f(d1\\times d2) * g(\\frac{ab}{d1\\times d2})\\\\ =\\sum\\limits_{d|a b} f(d) * g(\\frac{ab}{d})得到$(3)$式 性质四关于除数函数与幂函数的小结论（有关常函数） (f*I)(n)=\\sum\\limits_{d|n} f(d) \\times I(\\frac{n}{d})=\\sum\\limits_{d|n} f(d)推论 (ID_k*I)(n)=\\sum\\limits_{d|n} ID_k(d)=\\sum\\limits_(n)除数函数和幂函数可以相互转化 其实这就是一个简单的莫比乌斯反演。 性质五关于欧拉函数的小结论 (\\varphi * I)(n)=\\sum\\limits_{d|n} \\varphi(d)当$p$为质数且$d=p^m$时 \\sum\\limits_{d|n} \\varphi(d)=\\varphi(1)+\\sum\\limits_{i=1}^{m} \\varphi(p^i)\\\\ =1+\\sum\\limits_{i=1}^{m}(p^i-p^{i-1})=1+p^m-p^0=p^m=d综上，$p$为质数时，$(\\varphi *I)(p^m)=p^m$ 进一步推广得到$(\\varphi *I)(n)=n$ 即$\\varphi * I=ID$ 性质六莫比乌斯函数得小结论 (\\mu * ID)(n)=\\varphi(n)证明很短 \\mu * ID = \\mu * (\\varphi * I) = \\mu * I * \\varphi = \\epsilon * \\varphi = \\varphi还有$(\\mu * I)(n)=\\epsilon(n)$ 性质七\\mu * I=\\varepsilon\\\\ =\\sum\\limits_{d|n} \\mu(d)=\\sum\\limits_{i=0}^{k} (-1)^k C(k,i)\\\\ =\\sum\\limits_{i=0}^{k} (1)^{k-i} (-1)^k C(k,i)这不是二项式定理吗？简化为 (1-1)^k观察一下发现就是单位函数的定义了 常用积性函数单位函数 \\epsilon(n)= \\begin{cases} 1,n=1\\\\ 0,n>1 \\end{cases}是完全积性函数 幂函数 ID_k(n)=n^k特别的，当$k=1$时，$ID_1(n)=n$；$k=0$时，$ID_0(n)=1$ 是完全积性函数 除数函数 \\sigma_k(n)=\\sum\\limits_{d|n}d^k当$k=1$时，\\sigma_1(n)=\\sum\\limits_{d|n}d^k叫做约数和函数 当$k=0$时，\\sigma_0(n)=\\sum\\limits_{d|n}1叫做约数个数函数 莫比乌斯函数这个不用讲了吧。 欧拉函数参见我的这篇文章 常数函数I(n)=1莫比乌斯反演公式终于进入正题 g(n)=\\sum\\limits_{d|n} f(d)等价于 f(n)=\\sum\\limits_{d|n} \\mu(d) g(\\frac{n}{d})用更简单的形式为 f*I=g \\iff f=g*\\mu拿简单的形式来证明 \\begin{aligned} f*I=g\\\\ f*(I*\\mu)=g*\\mu\\\\ f*\\epsilon=g*\\mu\\\\ f=g*\\mu \\end{aligned}做题前的小补充整除分块一个小例题 给定一个整数$n\\in [1,10^9]$ 求 \\sum\\limits_{i=1}^n\\lfloor\\frac{n}{i}\\rfloor我们将他们按照$\\lfloor\\frac{n}{i}\\rfloor$来分成一个一个块，假设这一个块的左右边界分别是$L,R$ 则有 \\left\\lfloor\\frac{n}{L}\\right\\rfloor=\\left\\lfloor\\frac{n}{R}\\right\\rfloor\\\\ \\left\\lfloor\\frac{n}{L}\\right\\rfloor\\leq \\frac{n}{R}\\\\ \\frac{1}{\\left\\lfloor\\frac{n}{L}\\right\\rfloor} \\geq \\frac{R}{n}\\\\ R\\leq \\left\\lfloor\\frac{n}{\\left\\lfloor\\frac{n}{L}\\right\\rfloor}\\right\\rfloor又因为$R\\in Z$ R=\\left\\lfloor\\frac{n}{\\left\\lfloor\\frac{n}{L}\\right\\rfloor}\\right\\rfloor真例题这里 可以化简为以上的形式，就不分析了（考虑贡献） 代码123456789101112131415#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int n, ans;signed main(){ cin &gt;&gt; n; for(int l = 1, r; l &lt;= n; l = r + 1) { r = (n / (n / l)); ans += (r - l + 1) * (n / l); } cout &lt;&lt; ans; return 0;} 小小小扩展这里 我们实际上求的是 \\sum\\limits_{i=1}^n i*\\lfloor\\frac{n}{i}\\rfloor对于每一个块单独分析一波，就好了（高斯求和公式） Code1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int x, y;int sum(int x){ int ans = 0; for(int l = 1, r; l &lt;= x; l = r + 1) { r = (x / (x / l)); ans += (r - l + 1) * (x / l) * (l + r) / 2; } return ans;}signed main(){ cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; sum(y) - sum(x - 1); return 0;} 再来一个补充这里 莫比乌斯反演的应用一.关于$\\gcd$(\\gcd(i,j)==1)=\\sum\\limits_{d|\\gcd(i,j)} \\mu(d)证明 \\mu * I=\\epsilon\\\\ \\sum\\limits_{d|n}\\mu(d)=\\epsilon=(n==1)将$n=\\gcd(i,j)$带入即可得到结论 二.还是关于$\\gcd$\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{n} (\\gcd(i,j)==k)\\Rightarrow \\sum\\limits_{i=1}^{\\frac{n}{k}}\\sum\\limits_{j=1}^{\\frac{n}{k}} (\\gcd(i,j)==1)例题：求$1\\leq x\\leq n, 1\\leq y\\leq m, \\gcd(x,y)=1$的数量 \\Rightarrow \\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{m}\\sum\\limits_{d|\\gcd}^{min\\{n,m\\}}太难搞，改为枚举$\\gcd$ \\sum\\limits_{d=1}^{min\\{n,m\\}} \\sum\\limits_{i=1}^{n/d}\\sum\\limits_{j=1}^{m/d}\\mu(d)\\\\ \\Rightarrow \\sum\\limits_{d=1}^{min\\{n,m\\}}\\mu(d)\\sum\\limits_{i=1}^{n/d}\\sum\\limits_{j=1}^{m/d}\\\\ \\Rightarrow \\sum\\limits_{d=1}^{min\\{n,m\\}}\\mu(d)\\left\\lfloor\\frac{n}{d}\\right\\rfloor \\left\\lfloor\\frac{m}{d}\\right\\rfloor一个整除分块（二维）就做好了 杜教筛应用场景：求积性函数$f(n)$的前缀和，即 \\sum\\limits_{i=1}^{n} f(i)我们设 S(n)=\\sum\\limits_{i=1}^{n} f(i)我们构造另一个积性函数$g(n)$，那么有$(f*g)(n)$ \\sum\\limits_{i=1}^{n} (f*g)(i)=\\sum\\limits_{i=1}^{n}\\sum\\limits_{xy=1}f(x)g(y)\\\\ \\Rightarrow \\sum\\limits_{y=1}^{n}\\sum\\limits_{x=1}^{\\lfloor\\frac{n}{y}\\rfloor}f(x)g(y)\\\\ \\Rightarrow \\sum\\limits_{y=1}^{n} g(y) \\sum\\limits_{x=1}^{\\lfloor\\frac{n}{y}\\rfloor}=\\sum\\limits_{y=1}^{n} g(y) S(\\lfloor\\frac{n}{y}\\rfloor)\\\\ \\Rightarrow g(1)S(n)+\\sum\\limits_{y=2}{n}g(y)S(\\lfloor\\frac{n}{y}\\rfloor)移项可得 g(1)S(n)=\\sum\\limits_{i=1}^{n}(f*g)(i)-\\sum\\limits_{y=2}^{n}g(y)S(\\lfloor\\frac{n}{y}\\rfloor)这里我们令$f=\\mu$，因为$\\mu*I=\\epsilon$代入得 S(n)=1-\\sum\\limits_{y=2}^{n} S(\\lfloor\\frac{n}{y}\\rfloor)这样我们就得到了一个递推式，如果我们纯递归的话时间复杂度为$O(n^{\\frac{3}{4}})$ 我们有一个小技巧，先用线性筛筛出前$\\frac{2}{3}n$个$\\mu$，再来递推，就可以优化到$O(n^{\\frac{2}{3}})$ 很神奇吧，时间复杂度我不会证明（菜） 例题P3455 [POI2007]ZAP-Queries我们看一下这道题要我们求的式子 \\sum\\limits_{i=1}^{a}\\sum\\limits_{j=1}^{b}[\\gcd(i,j)=d]根据上面的定理可以得到 \\sum\\limits_{i=1}^{\\left\\lfloor a/d\\right\\rfloor}\\sum\\limits_{j=1}^{\\left\\lfloor b/d\\right\\rfloor}[\\gcd(i,j)=1]令$x=a/d,y=b/d$，反演得到 \\sum\\limits_{d=1}^{min\\{x,y\\}}\\mu(d)\\left\\lfloor\\frac{n}{d}\\right\\rfloor \\left\\lfloor\\frac{m}{d}\\right\\rfloor注意这一个式子中的$d$不是题目中的我们先预处理出来莫比乌斯函数的前缀和，然后用一个整出分块就做完了，还是很模板的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 5e4 + 10;int n, m;int miu[N], sum[N];bool vis[N];vector&lt;int&gt; pri;void init(int n){ for(int i = 1; i &lt;= n; i++) { miu[i] = 1; vis[i]= false; } for(int i = 2; i &lt;= n; i++) { if(vis[i] == true) continue; miu[i] = -1; //质数自己 ,-1 pri.push_back(i); for(int j = 2*i; j &lt;= n; j+=i) { vis[j] = true; if(j % (i*i) == 0) miu[j] = 0; else miu[j] *= -1; //取相反数, j的质因数可能有多个，奇数个就是-1 } } for(int i = 1; i&lt;= n; i ++) sum[i] = sum[i - 1] + miu[i]; return ; }int Get(int n, int m){ int ans = 0; for(int l = 1, r; l &lt;= min(n, m); l = r + 1) { r = min(n / (n / l), m / (m / l)); ans += (n / l) * (m / l) * (sum[r] - sum[l - 1]); }// cout &lt;&lt; ans &lt;&lt; endl; return ans;}signed main(){ ios::sync_with_stdio(false); init(50000); int T; cin &gt;&gt; T; while(T --) { int ans = 0, d = 0; cin &gt;&gt; n &gt;&gt; m &gt;&gt; d; cout &lt;&lt; Get(n / d, m / d) &lt;&lt; &quot;\\n&quot;; } return 0;}愉快的做出来第一道莫反题目","link":"/2021/07/13/Mobius/"}],"tags":[{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"}],"categories":[]}